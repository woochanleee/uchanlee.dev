---
templateKey: 'blog-post'
title: '[클린 아키텍처] 15장 - 아키텍처란?'
description: 아키텍처가 무엇인가 고민해 봅니다.
date: 2021-01-13 20:00:00
category: Clean Architecture
thumbnail: ./images/book.jpg
tags:
  - 아키텍처
---

![2020_retro_thumbnail](./images/book.jpg)

소프트웨어 아키텍트는 최고의 프로그래머이며, 코드와 동떨어져서는 안된다. 동시에,나머지 팀원들이 생산성을 극대화 할 수 있는 설계를 하도록 이끈다.

- 아키텍처의 주된 목적은 시스템의 생명주기를 지원하는 것이다.
  - 좋은 아키텍처는 시스템을 쉽게 이해하고, 쉽게 개발하며, 쉽게 유지보수하고, 쉽게 배포하게 해준다.
- 아키텍처의 궁극적인 목표는 시스템의 수명과 관련된 비용은 최소화하고, 프로그래머의 생산성은 최대화하는데 있다.

## Table of Contents

- [개발](#개발)
- [배포](#배포)
- [운영](#운영)
- [유지보수](#유지보수)
- [선택사항 열어 두기](#선택사항-열어-두기)
- [장치 독립성](#장치-독립성)
- [광고 우편](#광고-우편)
- [물리적 주소 할당](#물리적-주소-할당)
- [결론](#결론)

## 개발

개발하기 힘든 시스템이라면 수명이 길지도 않고 건강하지도 않을 것이다.

- 시스템 아키텍처는 개발팀이 시스템을 쉽게 개발할 수 있도록 만들어야 한다.

## 배포

소프트웨어 시스템이 사용될 수 있으려면 반드시 배포할 수 있어야 한다. 배포 비용이 높을수록 시스템의 유용성은 떨어진다.

- 소프트웨어 아키텍처는 시스템을 **단 한 번에 쉽게** 배포할 수 있도록 만드는 데 목표를 두어야 한다.

## 운영

아키텍처가 시스템 운영에 미치는 영향은 개발, 배포, 유지보수에 미치는 영향보다 적다.

좋은 소프트웨어 아키텍처는 시스템을 운영하는데 필요한 요구도 알려준다.

- 시스템 아키텍처는 **유스케이스, 기능, 시스템의 필수 행위**를 일급(first-class) 엔티티로 격상시키고, 이들 요소가 개발자에게 주요 목표로 인식되도록 해야 한다.
  - 이를 통해 시스템을 이해하기 쉬워지며, 따라서 개발과 유지보수에 큰 도움이 된다.

## 유지보수

유지보수는 모든 측면에서 봤을 때 소프트웨어 시스템에서 비용이 가장 많이 든다.

- 가장 큰 비용은 탐사(spelunking)와 이로 인한 위험부담에 있다.
  - 탐사: 기존 소프트웨어에 새로운 기능을 추가하거나 결함을 수정할 때, 소프트웨어를 파헤쳐서 어디를 고치는게 최선인지, 그리고 어떤 전략을 쓰는게 최적일지를 결정할 때 드는 비용이다.
- 아키텍처를 신중하게 만들면 이 비용을 크게 줄일 수 있다.
  - 컴포넌트 분리 및 안정된 인터페이스를 두어 서로 격리하기

## 선택사항 열어 두기

소프트웨어를 부드럽게 만들기 위해서는 **구조적 가치**를 중요하게 여겨야 한다.

- 소프트웨어를 부드럽게 유지하는 방법은 **선택사항을 가능한 한 많이, 그리고 가능한 한 오랫동안 열어 두는 것**이다.
  - 선택사항: 중요하지 않은 세부사항(detail)
- 모든 소프트웨어 시스템은 주요한 두 가지 구성요소로 분해할 수 있다. 정책(policy)과 세부사항이다.
  - 정책 요소는 모든 업무 규칙과 업무 절차를 구체화 한다. 정책이란 시스템의 진정한 가치가 살아 있는 곳이다.
  - 세부사항은 사람, 외부 시스템, 프로그래머가 정책과 소통할 때 필요한 요소지만, 정책이 가진 행위에는 조금도 영향을 끼치지 않는다. ex) 입출력 장치, 데이터베이스, 웹 시스템, 서버, 프레임워크, 통신 프로토콜 등
- 아키텍트의 목표는 시스템에서 정책을 가장 핵심적인 요소로 식별하고, 동시에 세부사항은 정책에 무관하게 만들 수 있는 형태의 시스템을 구축하는데 있다.
  - 따라서 세부사항을 결정하는 일은 미루거나 나중에 할 수 있다.
- **_좋은 아키텍트는 결정되지 않은 사항의 수를 최대화 한다._**

## 장치 독립성

1960년대에 프로그래머는 많은 실수를 저릴렀는데, 대표적인 실수 중 하나는 **코드를 입출력 장치와 결합해버린 일**이다. 프린터로 인쇄할 일이 생기면, 해당 프린터를 제어하는 입출력 명렁어를 직접 사용해서 코드를 작성했다.

- 이러한 코드는 **장치 종속적(device dependent)**이다.

왜 이러한 방법이 잘못된 것일까? → 장치를 바꾼다면 이 코드는 못 쓰게 되기 때문

- 오늘날의 운영체제는 입출력 장치를 소프트웨어 함수로 추상화 했고, 해당 함수는 천공카드와 같은 단위 레코드를 처리한다.

## 광고 우편

저자는 1960년대 후반에 광고 우편을 인쇄하는 회사에서 일했다고 한다.

- **장치 독립성**을 이용해 어떤 장치를 사용할지 전혀 모른채, 그리고 고려하지 않고도 프로그램을 작성할 수 있엇다고 한다.
- 이러한 프로그램에는 형태가 있었는데, 이 형태는 **정책을 세부사항으로부터 분리**했다.
  - 어떤 장치를 사용할지에 대한 결정을 연기시켰다.

## 물리적 주소 할당

시스템에서 고수준의 정책을 물리적 구조로부터 독립시킴으로써 애플리케이션과 하드웨어를 분리할 수 있다.

## 결론

좋은 아키텍트는 세부사항을 정책으로부터 신중하게 가려내고, 정책이 세부사항과 결합되지 않도록 엄격하게 분리한다. 이를 통해 정책은 세부사항에 관한 어떠한 지식도 갖지 못하게 되며, 어떤 경우에도 세부사항에 의존하지 않게 된다.

좋은 아키텍트는 세부사항에 대한 결정을 가능한 한 오랫동안 미룰 수 있는 방향으로 정책을 설계한다.

## References

- 모든 이미지의 출처는 **Clean Architecture 도서**에 있습니다.
