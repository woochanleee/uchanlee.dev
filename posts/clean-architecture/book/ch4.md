---
templateKey: 'blog-post'
title: '[클린 아키텍처] 4장 - 구조적 프로그래밍'
description: 구조적 프로그래밍의 탄생과 능력에 대해 알아봅니다.
date: 2021-01-07 23:53:00
category: Clean Architecture
thumbnail: ./images/book.jpg
tags:
  - 소프트웨어 개발이 과학과 같다고?
  - 테스트는 버그가 없음을 보여줄 수는 없다?
---

![2020_retro_thumbnail](./images/book.jpg)

에츠허르 비버 데이크스트라는 1930년에 로테르담(Rotterdam)에서 태어났다. 데이크스트라는 열악한 프로그래밍 환경 속에서 위대한 발견을 해냈다.

## Table of Contents

- [증명](#증명)
- [해로운 성명서](#해로운-성명서)
- [기능적 분해](#기능적-분해)
- [엄밀한 증명은 없었다](#엄밀한-증명은-없었다)
- [과학이 구출하다](#과학이-구출하다)
- [테스트](#테스트)
- [결론](#결론)

## 증명

데이크스트라가 초기에 인식한 문제는 다음과 같다.

- 프로그래밍은 어렵다.
- 프로그래머는 프로그래밍을 잘하지 못한다.

데이크스트라는 **증명(proof)**이라는 수학적인 원리를 적용하여 이 문제를 해결하고자 했다.

그리고 그는 수학자가 **유클리드 계층구조**를 사용하는 방식을 프로그래머도 사용할 수 있다고 믿었다. 이를 연구하다가 `goto` 문장이 모듈을 더 작은 단위로 재귀적으로 분해하는 과정에 방해가 되는 경우가 있다는 사실을 발견했고 더 **'좋은'** 방식인 `if/then/else`와 `do/while`과 같은 **분기와 반복이라는 단순한 제어 구조**에 해당한다는 사실을 발견했다.

위 사실은 즉, **모듈을 증명 가능하게 하는 바로 그 제어 구조가 모든 프로그램을 만들 수 있는 제어 구조의 최소 집합과 동일하다**는 사실이다. 구조적 프로그래밍은 이렇게 탄생했다.

## 해로운 성명서

1968년 데이크스트라는 CACM(Communications of the ACM) 편집자에게 편지를 썼고, 그 내용이 같은 해 3월호에 실렸다. 편지의 제목은 "goto문의 해로움(Go To Statement Considered Harmful)"이었다. 이 글에서 데이크스트라는 세 가지 제어 구조에 대한 자신의 의견을 얘기했다.

얼마 지나지 않아 프로그래밍 세계는 불이 붙었다. 양쪽 의견이 팽팽했고 10년 이상 지속되었다. 마침내 **데이크스트라가 승리**하며 이 논쟁은 사그라 들었다.

컴퓨터 언어가 진화하면서 `goto` 문장은 점점 밀려나며 마침내 거의 사라졌다.

## 기능적 분해

구조적 프로그래밍을 통해 모듈을 증명 가능한 더 작은 단위로 재귀적으로 분해할 수 있게 되었고, 이는 결국 모듈을 기능적으로 분해할 수 있음을 뜻했다.

즉, **거대한 문제 기술서를 받더라도 문제를 고수준의 기능들로 분해할 수 있다.** 그리고 각 기능들은 다시 저수준의 함수들로 분해할 수 있다. 게다가 이러한 분해 과정을 끝없이 반복할 수 있다. 게다가 이렇게 분해한 기능들은 구조적 프로그래밍의 제한된 제어 구조를 이용하여 표현할 수 있다.

이를 토대로 구조적 분석(structured analysis)이나 구조적 설계(structured design)와 같은 기법이 인기를 끌었으며, 이를 사용하면 프로그래머는 대규모 시스템을 모듈과 컴포넌트로 나눌 수 있고, 더 나아가 모듈과 컴포넌트는 입증할 수 있는 아주 작은 기능들로 세분화할 수 있다.

## 엄밀한 증명은 없었다

하지만 끝내 증명을 성공하진 못했다. 프로그램 관점에서 유클리드 계층구조는 만들어내지 못했다.

다행히 또다른 전략을 이용하여 상당히 성공한 과학적 방법(scientific method)이 있다.

## 과학이 구출하다

수학과 달리, 과학 이론과 법칙은 그 올바름을 절대 **증명할 수 없다.** 다른 실험을 통해 만유인력의 법칙이 잘못되었음이 밝혀질 가능성은 항상 열려 있다.

**즉, 과학적 방법은 반증은 가능하지만 증명은 불가능하다.**

과학은 서술된 내용이 사실임을 증명하는 방식이 아닌 서술이 틀렸음을 증명하는 방식으로 동작한다. 무수한 노력에도 반례를 들 수 없는 서술이 있다면 참이라고 본다.

## 테스트

데이크스트라는 "테스트는 버그가 있음을 보여줄 뿐, 버그가 없음을 보여줄 수는 없다."라고 말한 적이 있다.

다시 말해 **프로그램이 잘못되었음을 테스트를 통해 증명할 수는 있지만, 프로그램이 맞다고 증명할 수는 없다.**

테스트에 충분한 노력을 들였다면 테스트가 보장할 수 있는 것은 **프로그램이 목표에 부합할 만큼은 충분히 참이라고 여길 수 있게 해주는 것**이 전부다.

소프트웨어 개발은 과학과 같다. 최선을 다했음에도 올바르지 않음을 증명하는데 실패함으로써 올바름을 보여주기 때문이다. 이 증명 또한 입증 가능한 프로그램에게만 적용가능 하다.

구조적 프로그래밍은 프로그램을 증명 가능한 세부 기능 집합으로 재귀적으로 분해할 것을 강요한다. 그 다음 테스트를 통해 과학적 방법으로 참인지 거짓인지를 증명해낸다.

## 결론

구조적 프로그래밍이 오늘날까지 가치 있는 이유는 프로그래밍에서 **반증 가능한 단위를 만들어** 낼 수 있는 바로 이 능력 때문이다. 또 이 능력은 흔히 현대적 언어가 제약 없는 `goto` 문장은 지원하지 않는 이유이기도 하다. 뿐만 아니라 아키텍처 관점에서는 기능적 분해를 최고의 실천법 중 하나로 여기는 이유이기도 하다.

## References

- 모든 출처는 **Clean Architecture 도서**에 있습니다.
